# 7장 신뢰성 있는 데이터 전달

## 7.1 신뢰성 보장

### 카프카가 보장하는 점

#### 1. 파티션 내 메세지 순서 보장

- 메세지 A 다음 B가 쓰여졌고 동일한 프로듀서가 동일한 파티션에 썼을 경우 B의 오프셋이 A보다 큰 것을 보장
- 컨슈머 역시 A 조회 후 B 조회

#### 2. 모든 in-sync replica 파티션에 쓰여진 뒤에야 커밋된 것으로 간주

- 메세지가 완전히 커밋된 다음 응답 올지
- 리더에게 쓰여진 다음 응답 올지
- 네트워크로 전송된 다음 바로 응답이 올지 선택 가능

#### 3. 커밋된 메세지들은 최소 1개 작동 가능한 레플리카가 남아 있는 한 유실 x

#### 4. 컨슈머는 커밋된 메세지만 조회 가능

## 7.2 복제

- 토픽 = 파티션으로 이루어짐
- 파티션은 하나의 디스크에 저장
- 파티션은 다수의 레플리카 가질 수 있음 &rarr; 그 중 하나 리더
- 다른 레플리카는 리더와 동기화를 맞추며 최신 이벤트 복사 

#### in-sync 상태

- 주키퍼와의 활성 세션 &rarr; 6초 사이 주키퍼로 하트비트 전송
- 최근 10초 사이 리더로부터 메세지 조회
- 최근 10초 사이에 리더로부터 읽어 온 메세지들이 가장 최근 메세지

## 7.3 브로커 설정

### 7.3.1 복제 팩터

- 복제 팩터 = 3 &rarr; 브로커가 3대의 서로 다른 브로커에 3개 복제

### unclean leader election

- `clean leader election`: 파티션 리더를 사용할 수 없을 때 동기화 레플리카 중 하나가 리더로 선출
- `unclean leader election`: 동기화 레플리카가 존재하지 않고 비동기화 레플리카만 존재하는 경우
    - `unclean.leader.election.enable = true` &rarr; 나중에 합쳐지고 데이터 뒤섞이게됨
    - `unclean.leader.election.enable = false` &rarr; 파티션이 오프라인으로 남게 돼 신규 메세지 버리게 됨

## 7.5 신뢰성 있는 시스템에서 컨슈머 사용하기

### 7.5.1 신뢰성 있는 처리를 위해 중요한 컨슈머 설정

1. `group.id`: 두 개의 컨슈머가 같은 group.id를 갖는다면 파티션을 나눠서 가져감
2. `auto.offset.reset`: 오프셋 값이 없을 때 earliest, latest로 값 설정 가능
3. `enable.auto.commit`: 오프셋 커밋을 n초마다 자동으로 할것인지 결정
4. `auto.commit.interval.ms`: 위의 n초 설정

#### 컨슈머가 상태를 유지해야 하는 경우

- results 토픽 따로 만들어 메세지 보낸 뒤 results consumer에서 메세지 가져와 마지막 메세지로 업데이트